# 14장 요약 중첩된 데이터에 함수형 도구 사용하기

저번주에는 함수형 도구인 map, filter, reduce를 사용하고, 콜백함수 안에서 사용되는 조건이나, 변수들을 분리함으로써 코드의 냄새를 잡아봤습니다.
이번장에서는 고차 함수를 사용해서 객체를 다뤄봅시다!

## 🍜 필드명 명시적으로 만들기

```javascript
function incrementQuantity(item) {
  var quantity = item["quantity"];
  var newQuantity = quantity + 1;
  var newItem = objectSet(item, "quantity", newQuantity);
  return newItem;
}

//위에 있던 코드는, 함수 이름에 있는 암묵적 인자 냄새가 있었기 때문에 앞에서 배웠던, 암묵적 인자를 드러내기 리팩터링으로 없앴습니다.

function incrementField(object, field) {
  var value = item[field];
  var newValue = value + 1;
  var newItem = objectSet(item, field, newValue);
  return newItem;
}

function dobleField(object, field) {
  var value = item[field];
  var newValue = value * 2; //<- 요기에서 중복이 발생하고 있습니다 함수의 동작만 달라지면.. 어떻게 하죠?
  var newItem = objectSet(item, field, newValue);
  return newItem;
}
//여기에도 암묵적 인자 드러내기를 사용할 수 있을 것 같습니다!
```

### update 도출!

```javascript
var value = item[field];
var newValue = value + 1;
var newItem = objectSet(item, field, newValue);

//이부분을 함수로 도출해서
//암묵적 인자드러내기와 함수 본문을 콜백으로 바꾸기 리팩터링으로 동작을 함수 인자로 받도록 합니다!

function incrementField(item, field) {
  return updateField(item, field, function (value) {
    return value + 1;
  });
}

//특정 필드만 바꾸는 게 아니기 때문에 함수 이름을 update로 바꿉니다!
function update(item, field, modify) {
  var value = item[field];
  var newValue = modify(value);
  var newItem = objectSet(item, field, newValue);
  return newItem;
}
```

## 👻 중첩된 데이터에 update 사용하기

```javascript
var shirt = {
  name: "shirt",
  price: 13,
  options: {
    color: "blue",
    size: 3,
  },
};
```

중첩되지 않았으면 이런일이 일어나지는 않았겠지만..
중첩된 데이터를 가지고 한 번 update 해봅시다!

```javascript
//조회하고 변경하고 설정하는 것을 하는 함수인데요,
//먼저 그 부분들을 찾아야합니다!
function incrementSize(item) {
  var options = item.options; //조회
  var size = options.size; //조회
  var newSize = size + 1; //변경
  var newOptions = objectSet(options, "size", newSize); //설정
  var newItem = objectSet(item, "options", newOptions); //설정
  return newItem;
}

//update를 사용해서 리팩토링을 해봅시다
function incrementSize(item) {
  var options = item.options; //조회
  var newOptions = update(options, "size", increment); //변경
  var newItem = objectSet(item, "options", newOptions); //설정
  return newItem;
}

//자세히 보면 가운데 있던 조회 변경이 설정으로 변경되었습니다.
//조회, 변경, 설정 -> 이러면 또 update를 사용할 수 있습니다.

function incrementSize(item) {
  return update(item, "options", function (options) {
    return update(options, "size", increment);
  });
}

//오잉근데.. update가 중첩됐네요?
```

### 🎃 updateOption 도출하기

위의 코드를 보면 update를 두 번 호출하고, size 데이터도 두 단계로 중첩되어 있습니다 이 함수를 보면 데이터를 중첩된만큼 update를 호출해야 한다는 것을 알 수 있습니다.

**❗️ 여기서 잠깐**
</br>
암묵적 인자를 드러내기 (express implicit argument) 리팩터링 단계

1. 함수 이름에 있는 암묵적인 인자를 확인합니다.
2. 명시적인 인자를 추가합니다.
3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꿉니다.
4. 함수를 호출하는 곳을 고칩니다.

### 암묵적인 부분들

```javascript
//어떻게 수정할 것인지 -> increment
//어떤 것을 수정할 것인지 -> size

// 위 두 부분은 코드의 냄새가 심하게 납니다!
// 충분히 리팩토링 할 수 있을 것 같아요!
function incrementSize(item) {
  return update(item, "options", function (options) {
    return update(options, "size", increment);
  });
}
```

명시적 option 인자

```javascript
// 함수명에 있는 냄새제거, options들 제거 했는데 ...
//또 생겼네요

function updateOption(item, option) {
  return update(item, "options", function (options) {
    return update(options, option, increment);
  });
}
```

이런식으로 update3 까지 가버리는 부분들은 생략하겠습니다..
결론적으로는 재귀함수가 만들어지는데요?!

결론적으로는 아래와 같은 코드가 나옵니다.
객체와 중첩된 객체의 값을 가리키는 키 경로와 바꿀 함수를 인자로 받아 빠져나오는 모든 경로에 객체 복사본을 만듭니다!

```javascript
function nestedUpdate(object, keys, modify) {
  if (keys.length === 0) return modify(object); //종료조건(경로의 길이가 0일 때)
  var key1 = keys[0];
  var restOfKeys = drop_first(keys); // 종료조건에 가까워집니다(항목을 하나씩 없앰)
  return update(object, key1, function (value1) {
    return nestedUpdate(value1, restOfKeys, modify); // 재귀 호출
  });
}
```

음... 앞전에 봤던 깊은 복사가 생각나는데요?
deepCopy.. 앞장에서 했었죠?!
근데 재귀는 잘못설정하면 스택이 바닥날 수 있습니다! 조심하게 사용하는 방법을 알아볼까요?

## 🍏 안전한 재귀 사용법

### 1. 종료조건

재귀를 멈추려면 종료 조건이 필요합니다! 종료 조건은 재귀가 멈춰야 하는 곳에 있어야합니다.

```javascript
if (keys.length === 0) return modify(object);
```

### 2. 재귀 호출

재귀 함수는 최소 하나의 재귀 호출이 있어야 합니다. 재귀 호출이 필요한 곳에서 재귀 호출을 해야합니다.

### 3. 종료 조건에 다가가기

재귀 함수를 만든다면 최소 하나 이상의 인자가 점점 줄어들어야 합니다. 예를 들어 종료 조건이 빈 배열이라면 각 단계에서 배열 항목을 없애야합니다. 기 경로가 길면 중간 객체가 어떤 키를 가졌는지 기억하기 어렵습니다.

## 🐷 깊이 중첩된 구조를 설계할 때 생각할 점.

깊이 중첩된 구조를 설계할 때는 긴 키 경로가 필요한데, 객체가 어떤 키를 가졌는지 기억하기 어렵습니다.

```javascript
httpGet("http://my-blog.com/api/category/blog", function (blogCategory) {
  renderCategory(
    nestedUpdate(blogCategory, ["posts", "12", "author", "name"], capitalize)
  );
});

// blogCategory -> 중첩된 객체
// function(blogCategory) -> 콜백
// ['posts', '12', 'author', 'name'] -> 긴 키 경로
// capitalize 바꾸는 함수
```

이 코드는

1. 각 분류는 posts 키 아래 블로그 글을 담고 있다.
2. 각 블로그 글은 id를 통해 접근할 수 있다.
3. 블로그 글은 author 키 아래 글쓴이 사용자 레코드를 담고 있다.
4. 각 사용자 레코드는 name 키 아래 사용자 이름을 담고 있다.

경로에 따라 중첩된 각 단계에는 기억해야 할 새로운 데이터 구조가 있는데 시간이 좀 지나면 기억하기 정말 어려워 보입니다!
추상화 벽을 사용해봅시다!

### 깊이 중첩된 데이터에 추상화 벽 사용하기

전의 코드들을 살펴 보면 중첩된 각 단계의 데이터 구조를 모두 기억해야해 아주 불편했습니다.

```javascript
//명확한 이름을 가지고, 분류에 있는 블로그 글이 어떤 구조인지 몰라도 함수를 쓸 수 있습니다 <- 타입스크립트를 통해서 인자를 정의하면
function updatePostById(category, id, modifyPost) {
  return nestedUpdate(category, ["posts", id], modifyPost);
}

//명확한 이름을 가지고 글쓴이가 어떤 구조로 저장되어있는지 몰라도 함수를 쓸 수 있습니다.
function updateAuthor(post, modifyUser) {
  return update(post, "author", modifyUser);
}

//마찬가지!
function capitalizeName(user) {
  return update(user, "name", capitalize);
}

//모두 합쳤다!
updatePostById(blogCategory, "12", function (post) {
  return updateAuthor(post, capitalizeName);
});
```

각 동작의 이름이 있고, 기억해야할 것이 줄어들었기 때문에, 더 좋아졌습니다!
깊이 중첩된 데이터는 이해하기 어렵기 때문에 어떤 경로에 어떤 키가 있는지 기억하기 위해서는 위와 같이 추상화벽을 사용하면 알아야할 것들을 줄일 수 있습니다!
